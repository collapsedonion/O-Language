
#include List.olf
#include stdString.olf

struct:String{
    List[char] _data;
    
    init(){
        @me[_data] = [[me[_data] alloc()] init()];
        [me[_data] Add('\0')];
        return(me);
    }
    
    init(String source){
        [me init()];
        
        [me[_data] Copy(source[_data])];
        
        return(me);
    }
    
    [method [void Delete()]]{
        [me[_data] Delete()];
        free(me);
    }
    
    init(char~ source){
        [me init()];
        
        var:int size = stringSize(source);
        var:int counter = 0;
        
        while(counter < size){
            [me Add(source[counter])];
            @counter += 1;
        }
        
        return(me);
    }
    
    init(int i){
        [me init()];
        
        var:int index = 0;

        var:int remind = i;

        while(remind > 0){
            var:int newElement = remind % 10;

            [me Add(char(newElement) + '0')];

            @index = index + 1;
            @remind = remind / 10;
        }
        
        [me Reverse()];
        
        return(me);
    }
    
    [method [void Add(char c)]]{
        [me[_data] Pick()];
        [me[_data] Add(c)];
        [me[_data] Add('\0')];
    }
    
    [method [void Add(String str)]]{
        [me[_data] Pick()];
        [me[_data] Merge(str[_data])];
        if([me[_data] Last()] ? '\0'){
            return();
        }
        [me[_data] Add('\0')];
    }
    
    [method [char get(int id)]]{
        return([me[_data] get(id)]);
    }
    
    [method [void set(int id, char c)]]{
        [me[_data] set(id, c)];
    }
    
    [method [int size()]]{
        return([me[_data] Count()] - 1);
    }
    
    [method [char~ c_style()]]{
        return(me[_data][_content][_content]);
    }
    
    [method [bool cmp(String str)]]{
        if([str size()] ? [me size()]){
            var:int counter = 0;
        
            while(counter < [me size()]){
                if(([me get(counter)] ? [str get(counter)]) ? false){
                    return(false);
                }
                @counter += 1;
            }
        }
        return(false);
    }
    
    [method [void Reverse()]]{
        var:int first = 0;
        var:int last = [me size()] - 1;
        
        while(last > first){
            var:char buf1 = [me get(first)];
            var:char buf2 = [me get(last)];
            
            [me set(last, buf1)];
            [me set(first, buf2)];
            
            @first += 1;
            @last -= 1;
        }
    }
    
    [method [int ParseInt()]]{
        var:int result = 0;
        
        var:int multiplier = 1;
        
        var:int index = 0;
        var:bool finding = true;
        var:int start = [me size()];
        
        while(index < [me size()] & finding){
            if(isDigit([me get(index)]) ? false){
                @finding = false;
                @start = index
            }
            @index += 1;
        }
        
        while(start > 0){
            var:int new_elem = int([me get(start - 1)] - '0');

            @result += new_elem * multiplier;
            @multiplier *= 10;
            
            
            @start -= 1;
        }
        
        return(result);
    }
}
